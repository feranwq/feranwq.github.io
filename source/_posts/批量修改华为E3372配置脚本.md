title: 批量修改华为E3372配置脚本
date:
tags: 
mp3: 
cover: http://wx1.sinaimg.cn/large/77b6881dgy1fj9zwokjpoj21kw1kwdmq.jpg
---

### 公司有几十个4G网卡需要批量设置,写了个小脚本来自动检测并修改配置,python2.7


```
#!/usr/bin/python
# coding: utf-8

import re
import base64, hashlib
import urllib2
import urllib
import cookielib
import time
from jsbn import RSAKey



# 预编译匹配规则
re_csrf_token = re.compile(r'(?<="csrf_token" content=").+(?="/>)')


# 用到的url
login_url = 'http://192.168.8.1/html/home.html'


# 初始化opener
cookie = cookielib.CookieJar()
opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))


def try_login():
    # 此函数用获取token的方式探测网卡是启动
    try:
        csrf_token = opener.open(login_url, timeout=1).read()
        g_requestVerificationToken = re_csrf_token.findall(csrf_token)
        return g_requestVerificationToken
    except:
        pass


def data_roaming_open():
    # 此函数用于打开数据漫游开关,正常返回字符串'<?xml version="1.0" encoding="UTF-8"?><response>OK</response>'

    # 数据漫游url
    data_roaming_url = 'http://192.168.8.1/api/dialup/connection'

    # 构造POST数据
    data_roaming_postdata = '''<?xml version="1.0" encoding="UTF-8"?><request><RoamAutoConnectEnable>1</RoamAutoConnectEnable>\
    <MaxIdelTime>0</MaxIdelTime><ConnectMode>0</ConnectMode><MTU>1500</MTU><auto_dial_switch>1</auto_dial_switch><pdp_always_on>1\
    </pdp_always_on></request>'''

    # 获取token
    csrf_token = opener.open(login_url).read()
    g_requestVerificationToken = re_csrf_token.findall(csrf_token)

    # 添加到header并发送POST请求
    opener.addheaders = [('__RequestVerificationToken', g_requestVerificationToken[0])]
    data_roaming = opener.open(data_roaming_url, data_roaming_postdata).read()
    return data_roaming


def profile_add():
    # 此函数用于创建中国移动APN为cmiot的profile,正常返回字符串'<?xml version="1.0" encoding="UTF-8"?><response>OK</response>'
    # 重复返回字符串'<?xml version="1.0" encoding="UTF-8"?>\r\n<error>\r\n<code>107723</code>\r\n<message></message>\r\n</error>\r\n'

    # profile url
    profiles_url = 'http://192.168.8.1/api/dialup/profiles'

    # RSA加密所需公钥获取url
    publickey_url = 'http://192.168.8.1/api/webserver/publickey'

    # 预编译匹配规则
    encpubkeyn_compile = re.compile(r'<encpubkeyn>(.*)</encpubkeyn>')
    encpubkeye_compile = re.compile(r'<encpubkeye>(.*)</encpubkeye>')

    # 构造POST数据
    profile_add_data = '''<?xml version="1.0" encoding="UTF-8"?><request><Delete>0</Delete><SetDefault>0</SetDefault><Modify>1\
    </Modify><Profile><Index></Index><IsValid>1</IsValid><Name>中国移动</Name><ApnIsStatic>1</ApnIsStatic><ApnName>cmiot</ApnName>\
    <DialupNum>*99#</DialupNum><Username></Username><Password></Password><AuthMode>0</AuthMode><IpIsStatic></IpIsStatic><IpAddress>\
    </IpAddress><DnsIsStatic></DnsIsStatic><PrimaryDns></PrimaryDns><SecondaryDns></SecondaryDns><ReadOnly>0</ReadOnly><iptype>2</iptype>\
    </Profile></request>'''

    # 获取token
    csrf_token = opener.open(login_url).read()
    g_requestVerificationToken = re_csrf_token.findall(csrf_token)

    # 获取公钥
    publickey = opener.open(publickey_url).read()
    encpubkeyn = encpubkeyn_compile.findall(publickey)
    encpubkeye = encpubkeye_compile.findall(publickey)

    # 添加到header
    opener.addheaders = [('__RequestVerificationToken', g_requestVerificationToken[0]),
                         ('encrypt_transmit', 'encrypt_transmit'), ]
    # 加密数据
    rsa = RSAKey()
    rsa.setPublic(encpubkeyn[0], encpubkeye[0])
    encstring = base64.b64encode(profile_add_data)
    num = len(encstring) / 245.0
    restotal = ''
    i = 0
    while i < num:
        encdata = encstring[i * 245: i * 245 + 245]
        res = rsa.encrypt(encdata)
        restotal += res
        i = i + 1

    # POST数据
    profile = opener.open(profiles_url, restotal).read()
    return profile

while True:
    status = try_login()
    if status:
        print 'begin create profile', profile_add(), data_roaming_open()
        time.sleep(15)

    else:
        print 'cannot connect e3372'







```
